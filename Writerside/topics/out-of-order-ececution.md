# out-of-order instruction

## 1、概述
在实际的代码运行中有这么一个事实：  
**程序实际的执行的次序与代码书写的次序并不是一一对应的关系**。

编译器开发人员和处理器供应商会对程序进行优化，以便获取更高的代码执行效率和处理器利用率。 编译器开发人员和 CPU 厂商遵循这么一条基本规则：  
               **_不得修改单线程程序的行为_**。

## 2、编译器优化导致的执行乱序
编译器只能看到单线程下代码的执行依赖关系，基于这种依赖关系，编译可以对实际代码的指令进行调节，只要不改变最终执行效果即可。
这个会导致我们实际书写的代码次序与编译器生成的二进制代码逻辑可能会有上下的替换，但是不影响单线程下的执行逻辑。在编译器的视角下是没有共享的数据的概念，
他当然会改变一些共享数据的 load 和 store 行为。
（更多细节可以见[memory-ordering-at-compile-time](memory_order_compile_time.md)）

## 3、处理器优化导致的执行乱序和可见性问题
CPU 为了更加高效的执行指令，采取了流水线的方式。流水线是并行的，比如说一个 CPU 有一个加法器和一个除法器，那么一条加法指令和一条除法指令就
可能同时存储执行情况。由于采用了流水线的方式就可能出现这种情况：一条除法指令后面紧跟着一条加法指令，但是由于除法指令执行时间长，那么加法指令就可能
先完成了。在比如两条访存指令，由于某一条命中了 cache ，导致其先执行完毕。  
一般情况下，指令乱序并不是 CPU 在执行指令之前可以去调整顺序。 CPU 总是顺序地去内存中取指令，然后按顺序放入到流水线中。但是指令执行时的各种个条件和
指令之间的相互影响，可能导致顺序放入流水线的指令，最终乱序执行。产生 “**顺序流入，乱序流出**” 的现象。  
流水线除了资源不足的情况下会卡住(由于只有固定个数的加法器导致多条加法操作卡住)外，指令之间的相关性也会导致流水线阻塞，因为 CPU 的乱序执行不是随意执行
而是需要保证单线程程序上下因果关系。
```C++
a++;
b = foo(a);
c--;
```
由于上述代码中, b = foo(a) 依赖于 a，因此该代码会阻塞，直到 a++ 被执行完毕，然而 c-- 由于没有依赖，所以 c-- 可能先于 b = foo(a) 执行。
当然，这段代码，可能在编译阶段就被优化为了以下形式： 让相互依赖的两个指令拉开距离，让后续的指令在进入流水线时，被依赖的指令已经执行完毕。
```C++
a++;
c--;
.....
b = foo(a);
```
## Ref
[wikipedia_out_of_order_execution](https://en.wikipedia.org/wiki/Out-of-order_execution)  
[理解内存屏障](https://blog.csdn.net/armlinuxww/article/details/105530025)  