# Cache Line

### 1、什么是 Cache Line ?
Cache Line 可以理解为 CPU 缓存中的最小单位。内存与高速缓存以及高速缓存之间的数据移动不是以字节或者 word 为单位的，而是以缓存行为单位。
一般的 64 位操作系统缓存行大小为 64 字节。
Cache Line 的大小范围一般为 16 -> 256 Byte。
### 2、Cache Line 如何生效 ？
当特定的 CPU 首次访问给定的数据项时，该数据项将不存在于该 CPU 的缓存中，这意味着发生了“缓存未命中”（或更具体地说，“启动”或“预热”缓存未命中）
缓存未命中意味着 CPU 在从内存中获取数据时必须等待（或“停滞”）数百个周期，然后该数据将被加载到该 CPU 的缓存中，以便后续访问可以在缓存中找到它，从而全速运行。
一段时间后，CPU 的缓存将填满，后续的未命中可能需要从缓存中弹出一个 Cache Line，以便为新获取的 Cache Line 腾出空间。 这种缓存未命中被称为“容量未命中”，因为它是由缓存容量有限引起的
然而，大多数缓存可能会被迫弹出旧项目，以便为新项目腾出空间，即使它们尚未满。 
这是因为大型缓存是作为硬件哈希表实现的，具有固定大小的哈希桶（或 CPU 设计者所说的“集合”）并且没有链接，如下图所示。

<img alt="img_1.png" src="CacheLine1.png" width="500" height="800"/>

该缓存有十六个“组”和两个“路”，总共 32 个“行”，每个条目包含一个 256 字节“缓存行”，这是一个 256 字节对齐的内存块。
这个缓存线的大小有点大，但使十六进制运算变得更简单。
用硬件术语来说，这是一个双向组关联缓存，类似于具有 16 个存储桶的软件哈希表，其中每个存储桶的哈希链最多包含两个元素。
大小（在本例中为 32 条缓存线）和关联性（在本例中为 2 条）统称为缓存的“几何结构”。
由于该缓存是在硬件中实现的，因此哈希函数非常简单：从内存地址中提取四位。

每个框对应一个缓存条目，该条目可以包含 256 字节的缓存行。
但是，缓存条目可以为空，如图中的空框所示。 其余的框用它们包含的缓存行的内存地址进行标记。
由于高速缓存行必须是 256 字节对齐的，因此每个地址的低八位为零，并且硬件哈希函数的选择意味着下一个高四位与哈希行号匹配。

如果程序代码位于地址 0x43210E00 到 0x43210EFF，并且该程序按顺序访问从 0x12345000 到 0x12345EFF 的数据，
则可能会出现图中所示的情况。 
假设程序现在要访问位置 0x12345F00。 
该位置散列到第0xF行，并且该行的两路都是空的，因此可以容纳相应的256字节行。 
如果程序要访问位置 0x1233000（散列到行 0x0），则相应的 256 字节高速缓存行可以采用方式 1 来容纳。
但是，如果程序要访问位置 0x1233E00（散列到行 0xE），则现有的缓存行之一 必须从高速缓存中弹出行，以便为新的高速缓存行腾出空间。 
如果稍后访问该弹出行，则会导致高速缓存未命中。 这种高速缓存未命中被称为“关联性未命中”。

到目前为止，我们只考虑 CPU 读取数据项的情况。 
当它进行写入时会发生什么？ 
因为所有 CPU 都同意给定数据项的值非常重要，
所以在给定 CPU 写入该数据项之前，它必须首先使其从其他 CPU 的缓存中删除或“无效”。
一旦失效完成，CPU 就可以安全地修改数据项。 
如果数据项存在于该 CPU 的缓存中，但是只读的，则该过程称为“写入未命中”。 
一旦给定的 CPU 完成了使其他 CPU 的缓存中的给定数据项无效，该 CPU 就可以重复写入（和读取）该数据项。

### 3、实际编程中 Cache Line 的影响 ？
```Bash
# 查看缓存行大小
cat /sys/devices/system/cpu/cpu1/cache/index0/coherency_line_size
```

cache line 在循环计算中的小影响
```C++
for (int i = 0; i < N; i+=k)
    arr[i] *= 3;
```
步长在1到 16 范围内，循环运行时间几乎不变。但从16开始，每次步长加倍，运行时间减半。
由于16个整型数占用 64 字节（一个缓存行），for循环步长在1到16之间必定接触到相同数目的缓存行：
即数组中所有的缓存行。 当步长为32，我们只有大约每两个缓存行接触一次，当步长为64，只有每四个接触一次。



## Ref
[Memory Barriers: a Hardware View for Software Hackers](http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf)

